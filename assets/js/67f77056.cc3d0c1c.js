"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[946],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,f=u["".concat(i,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(f,s(s({ref:t},p),{},{components:n})):a.createElement(f,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4292:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return i},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),s=["components"],l={title:"Workflow",sidebar_position:2},i="Workflow",c={unversionedId:"modules/workflow",id:"modules/workflow",isDocsHomePage:!1,title:"Workflow",description:"This section describes how to build dependencies between modules and how to access results from their ancestors.",source:"@site/docs/modules/workflow.md",sourceDirName:"modules",slug:"/modules/workflow",permalink:"/magda/docs/next/modules/workflow",editUrl:"https://github.com/NeuroSYS-pl/magda/edit/main/web/docs/modules/workflow.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Workflow",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"General outlook",permalink:"/magda/docs/next/modules/module"},next:{title:"Interfaces",permalink:"/magda/docs/next/modules/interfaces"}},p=[{value:"Idea",id:"idea",children:[]},{value:"How to define acceptable predecessors - decorator <code>@accept</code>",id:"how-to-define-acceptable-predecessors---decorator-accept",children:[]},{value:"How to define dependencies",id:"how-to-define-dependencies",children:[]},{value:"How to access results returned by ancestor modules",id:"how-to-access-results-returned-by-ancestor-modules",children:[]}],d={toc:p};function u(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"workflow"},"Workflow"),(0,o.kt)("p",null,"This section describes how to build dependencies between modules and how to access results from their ancestors. "),(0,o.kt)("h2",{id:"idea"},"Idea"),(0,o.kt)("p",null,"The main idea of building a modules dependency graph (",(0,o.kt)("em",{parentName:"p"},"Directed Acyclic Graph"),") is to specify the predecessors of a given module either from code or from a configuration file. Modules are obliged to have a proper input specified in the ",(0,o.kt)("inlineCode",{parentName:"p"},"@accept")," decorator, which can take a class name or a data interface to be returned (described in detail on the page ",(0,o.kt)("a",{parentName:"p",href:"/magda/docs/next/modules/interfaces"},"Interfaces"),"). "),(0,o.kt)("p",null,"This page covers three key aspects:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"How to define acceptable predecessors."),(0,o.kt)("li",{parentName:"ol"},"How to assign a concrete predecessor from code or from config."),(0,o.kt)("li",{parentName:"ol"},"How to access the predecessors' results in code of the given module.")),(0,o.kt)("h2",{id:"how-to-define-acceptable-predecessors---decorator-accept"},"How to define acceptable predecessors - decorator ",(0,o.kt)("inlineCode",{parentName:"h2"},"@accept")),(0,o.kt)("p",null,"We use the ",(0,o.kt)("inlineCode",{parentName:"p"},"@accept")," decorator above the definition of the module class in order to specify the list of accepted predecessors of the module. The decorator can take the name of another Module class, the module itself or an interface of accepted data type that the predecessor may return. Single or multiple entities might be passed to the decorator. "),(0,o.kt)("p",null,"Below you can see the correct ways of specifying the predecessors of a module: "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"A module can accept another module:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"@finalize\nclass SamplePredecessorModule(Module.Runtime):\n    def run(self, *args, **kwargs):\n        # some predecessors logic happens here\n        ...\n\n@accept(SamplePredecessorModule)\n@finalize\nclass ModuleSample(Module.Runtime):\n    def run(self, *args, **kwargs):\n        # some logic happens here\n        ...\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"A module can accept a module of the same type:")),(0,o.kt)("p",null,"In this case ",(0,o.kt)("inlineCode",{parentName:"p"},"self=True")," has to be included in the decorator"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"@accept(self=True)\n@finalize\nclass ModuleSample(Module.Runtime):\n    def run(self, *args, **kwargs):\n        # some logic happens here\n        ...\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"A module can accept a data interface:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from magda.module import Module\n\nclass CorrectDataInterface(Module.Interface):\n    pass\n\n@accept(CorrectDataInterface)\n@finalize\nclass ModuleSample(Module.Runtime):\n    def run(self, *args, **kwargs):\n        # some logic happens here\n        ...\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"A module can accept multiple modules and interfaces at once:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"@finalize\nclass SampleAnotherPredecessorModule(Module.Runtime):\n    def run(self, *args, **kwargs):\n        # some another predecessors logic happens here\n        ...\n\n@accept(SamplePredecessorModule, SampleAnotherPredecessorModule, CorrectDataInterface)\n@finalize\nclass AnotherModuleSample(Module.Runtime):\n    def run(self, *args, **kwargs):\n        # some logic happens here\n        ...\n")),(0,o.kt)("p",null,"On the other hand, below you can see examples with entities that cannot be passed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"@accept")," decorator."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"A module cannot accept an interface other than ",(0,o.kt)("inlineCode",{parentName:"strong"},"Module.Interface"),":")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"class IncorrectInterface(ABC):\n    pass\n\n@accept(IncorrectInterface) # Wrong: interface other than MAGDA is passed\n@finalize\nclass  ModuleSample(Module.Runtime):\n    def run(self, *args, **kwargs):\n        # some logic happens here\n        ...\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"A module cannot accept a ",(0,o.kt)("inlineCode",{parentName:"strong"},"None")," value")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"@accept(None) # Wrong: None value cannot be passed to @accept decorator\n@finalize\nclass  ModuleSample(Module.Runtime):\n    def run(self, *args, **kwargs):\n        # some logic happens here\n        ...\n")),(0,o.kt)("p",null,"Having specified accepted inputs of particular modules, the next step is to define the structure of the pipeline by creating dependencies of concrete instances. Keep in mind, that the pipeline's graph will not be created when dependencies of wrong types are assigned to the modules. This restriction cannot be omitted in any way. "),(0,o.kt)("h2",{id:"how-to-define-dependencies"},"How to define dependencies"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"TODO")),(0,o.kt)("h2",{id:"how-to-access-results-returned-by-ancestor-modules"},"How to access results returned by ancestor modules"),(0,o.kt)("p",null,"In the simplest case, the output from a specific module can be accessed in the ",(0,o.kt)("inlineCode",{parentName:"p"},"run")," function of another module via the ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," parameter that is of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ResultSet")," type. ",(0,o.kt)("inlineCode",{parentName:"p"},"ResultSet")," has the following methods, for accessing the results, implemented:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"get")," - returns a single, plain result (without metadata) from a specified module. It raises an Exception when the identifier passed to the method refers to many results,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"has")," - indicates if results from specified modules are available,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"of")," - lists plain results (without metadata) from specified modules.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"type Identifier = Union[Module.Runtime, Module.Builder, Module.Interface]\n\nResultSet.get(identifier: Identifier): Module.Result\nResultSet.has(identifier: Identifier): bool\nResultSet.of(identifier: Identifier): List[Module.Result]\n")),(0,o.kt)("p",null,"Results are accessible by ",(0,o.kt)("strong",{parentName:"p"},"module class names or by interfaces"),": "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# TODO: Example\n")),(0,o.kt)("p",null,"Moreover, it is also possible to access a result by the ",(0,o.kt)("strong",{parentName:"p"},"tag given in the @expose decorator"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# TODO: Example\n")),(0,o.kt)("p",null,"Although it is ",(0,o.kt)("strong",{parentName:"p"},"not a recommended")," solution, a module's result can be also accessed by ",(0,o.kt)("strong",{parentName:"p"},"module registered name"),". A module shouldn't rely on specific names of modules. It is highly recommended to use either interfaces, modules' type, or exposed names. However, in very rare cases this functionality might be useful:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# TODO: Example\n")))}u.isMDXComponent=!0}}]);